#!/usr/bin/env python3

import argparse
import cantools
import os

from data_log import DataLog, Message
from motec_log import MotecLog

DESCRIPTION = """Generates MoTeC .ld files from external log files generated by: CAN bus dumps, CSV
 files, or COBB Accessport CSV files"""

EPILOG = """The CAN bus log must be the same format as what is generated by 'candump' with the '-l'
option from the linux package can-utils. A MoTeC channel will be created for every signal in the
DBC file that has messages in the CAN log. The signal name and units will be directly copied from
the DBC file.

CSV files must have time as their first column. A MoTeC channel will be generated for all remaining
columns. All channels will not have any units assigned.

COBB Accessport CSV logs are simply generated by starting a logging session on the accessport. A
MoTeC channel will be created for every channel logged, the name and units will be directly copied
over.
"""

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
    parser.add_argument("log", type=str, help="Path to logfile")
    parser.add_argument("log_type", type=str, help="Type of log to process", \
        choices=["CAN", "CSV", "ACCESSPORT"])

    parser.add_argument("--output", type=str, \
        help="Name of output file, defaults to the same filename as 'log'")
    parser.add_argument("--frequency", type=float, default=20.0, \
        help="Fixed frequency to resample all channels at")
    parser.add_argument("--dbc", type=str, help="Path to DBC file, required if log type CAN")

    parser.add_argument("--driver", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--vehicle_id", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--vehicle_weight", type=int, default=0, help="Motec log metadata field")
    parser.add_argument("--vehicle_type", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--vehicle_comment", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--venue_name", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--event_name", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--event_session", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--long_comment", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--short_comment", type=str, default="", help="Motec log metadata field")
    parser.add_argument(
        "--workers",
        type=int,
        default=None,
        help="Number of worker processes for channel conversion (defaults to CPU count)",
    )
    args = parser.parse_args()

    if args.log:
        args.log = os.path.expanduser(args.log)
    if args.dbc:
        args.dbc = os.path.expanduser(args.dbc)
    if args.output:
        args.output = os.path.expanduser(args.output)

    # Make sure our input files are valid
    if not os.path.isfile(args.log):
        print("ERROR: log file %s does not exist" % args.log)
        exit(1)

    if args.log_type == "CAN" and not os.path.isfile(args.dbc):
        print("ERROR: DBC file %s does not exist" % args.dbc)
        exit(1)

    print("Loading log...")
    with open(args.log, "r") as file:
        lines = file.readlines()

    # Create our data log from the input data
    data_log = DataLog()

    if args.log_type == "CAN":
        if not os.path.isfile(args.dbc):
            print("ERROR: DBC file %s does not exist" % args.dbc)
            exit(1)

        # Load the databse and log file
        print("Loading DBC...")
        can_db = cantools.database.load_file(args.dbc)

        print("Extracting data...")
        data_log.from_can_log(lines, can_db)
    elif args.log_type == "CSV":
        print("Extracting data...")
        data_log.from_csv_log(lines)
    elif args.log_type == "ACCESSPORT":
        print("Extracting data...")
        data_log.from_accessport_log(lines)

    if not data_log.channels:
        print("ERROR: Failed to find any channels in log data")
        exit(1)

    beacon_times = []
    if "Beacon" in data_log.channels:
        beacon_messages = [m for m in data_log.channels["Beacon"].messages if int(m.value) == 1]
        beacon_times = [m.timestamp for m in beacon_messages]
        # Build a Lap counter channel from Beacon pulses (lap starts at 1)
        if beacon_times:
            lap_channel_name = "Lap"
            if lap_channel_name not in data_log.channels:
                data_log.add_channel(lap_channel_name, "", int, 0)
            lap_messages = []
            lap = 1
            start_time = data_log.start()
            lap_messages.append(Message(start_time, lap))
            for ts in beacon_times:
                lap += 1
                lap_messages.append(Message(ts, lap))
            data_log.channels[lap_channel_name].messages = lap_messages
        print("Beacon pulses detected:", len(beacon_times))

    print("Parsed %.1fs log with %s channels:" % (data_log.duration(), len(data_log.channels)))
    for channel_name, channel in data_log.channels.items():
        print("\t%s" % channel)

    # Resample all channels except Beacon (events) to a fixed frequency.
    # Beacon is left as-is to preserve discrete lap markers.
    data_log.resample(args.frequency, skip_channels={"Beacon"})

    print("Converting to MoTeC log...")

    motec_log = MotecLog()
    motec_log.driver = args.driver
    motec_log.vehicle_id = args.vehicle_id
    motec_log.vehicle_weight = args.vehicle_weight
    motec_log.vehicle_type = args.vehicle_type
    motec_log.vehicle_comment = args.vehicle_comment
    motec_log.venue_name = args.venue_name
    motec_log.event_name = args.event_name
    motec_log.event_session = args.event_session
    motec_log.long_comment = args.long_comment
    motec_log.short_comment = args.short_comment

    motec_log.initialize()
    motec_log.add_all_channels(data_log, max_workers=args.workers)
    if beacon_times:
        motec_log.add_beacons(beacon_times)

    print("Saving MoTeC log...")
    if args.output:
        ld_filename = os.path.splitext(args.output)[0] + ".ld"
    else:
        # Copy the path and name from the source file, but change the extension
        candump_dir, candump_filename = os.path.split(args.log)
        candump_filename = os.path.splitext(candump_filename)[0]
        ld_filename = os.path.join(candump_dir, candump_filename + ".ld")

    output_dir = os.path.dirname(ld_filename)
    if output_dir and not os.path.isdir(output_dir):
        print("Directory '%s' does not exist, will create it" % output_dir)
        os.makedirs(output_dir)

    motec_log.write(ld_filename)
    print("Done!")
